% minimal tic-tac-toe with alpha-beta (computer = o, human = x)

:- dynamic board/1.
init :- retractall(board()), assert(board([,,,,,,,,])).
:- init.

% mark positions generator
mark(P,[X|_],1,1) :- var(X), X=P.
mark(P,[,X|],2,1) :- var(X), X=P.
mark(P,[,,X|_],3,1) :- var(X), X=P.
mark(P,[,,,X|],1,2) :- var(X), X=P.
mark(P,[,,,,X|_],2,2) :- var(X), X=P.
mark(P,[,,,,,X|],3,2) :- var(X), X=P.
mark(P,[,,,,,,X|_],1,3) :- var(X), X=P.
mark(P,[,,,,,,,X|],2,3) :- var(X), X=P.
mark(P,[,,,,,,,,X|_],3,3) :- var(X), X=P.

% move applies mark to produce new board
move(P,(1,1),[X1|R],[P|R]) :- var(X1).
move(P,(2,1),[X1,X2|R],[X1,P|R]) :- var(X2).
move(P,(3,1),[X1,X2,X3|R],[X1,X2,P|R]) :- var(X3).
move(P,(1,2),[X1,X2,X3,X4|R],[X1,X2,X3,P|R]) :- var(X4).
move(P,(2,2),[X1,X2,X3,X4,X5|R],[X1,X2,X3,X4,P|R]) :- var(X5).
move(P,(3,2),[X1,X2,X3,X4,X5,X6|R],[X1,X2,X3,X4,X5,P|R]) :- var(X6).
move(P,(1,3),[X1,X2,X3,X4,X5,X6,X7|R],[X1,X2,X3,X4,X5,X6,P|R]) :- var(X7).
move(P,(2,3),[X1,X2,X3,X4,X5,X6,X7,X8|R],[X1,X2,X3,X4,X5,X6,X7,P|R]) :- var(X8).
move(P,(3,3),[X1,X2,X3,X4,X5,X6,X7,X8,X9|R],[X1,X2,X3,X4,X5,X6,X7,X8,P|R]) :- var(X9).

% record a move into global board
record(Player,X,Y) :-
    retract(board(B)),
    mark(Player,B,X,Y),
    assert(board(B)).

% win patterns
win([A,B,C|_],P) :- A==P,B==P,C==P.
win([,,,A,B,C|],P) :- A==P,B==P,C==P.
win([,,,,,,A,B,C],P) :- A==P,B==P,C==P.
win([A,,,B,,,C,,],P) :- A==P,B==P,C==P.
win([,A,,,B,,,C,],P) :- A==P,B==P,C==P.
win([,,A,,,B,,,C],P) :- A==P,B==P,C==P.
win([A,,,,B,,,,C],P) :- A==P,B==P,C==P.
win([,,A,,B,,C,,],P) :- A==P,B==P,C==P.

% a line is open if each pos is free or equals Player
open([Z1,Z2,Z3|_],Player) :- (var(Z1);Z1==Player),(var(Z2);Z2==Player),(var(Z3);Z3==Player).
open([,,,Z1,Z2,Z3|],Player) :- (var(Z1);Z1==Player),(var(Z2);Z2==Player),(var(Z3);Z3==Player).
open([,,,,,,Z1,Z2,Z3],Player) :- (var(Z1);Z1==Player),(var(Z2);Z2==Player),(var(Z3);Z3==Player).
open([Z1,,,Z2,,,Z3,,],Player) :- (var(Z1);Z1==Player),(var(Z2);Z2==Player),(var(Z3);Z3==Player).
open([,Z1,,,Z2,,,Z3,],Player) :- (var(Z1);Z1==Player),(var(Z2);Z2==Player),(var(Z3);Z3==Player).
open([,,Z1,,,Z2,,,Z3],Player) :- (var(Z1);Z1==Player),(var(Z2);Z2==Player),(var(Z3);Z3==Player).
open([Z1,,,,Z2,,,,Z3],Player) :- (var(Z1);Z1==Player),(var(Z2);Z2==Player),(var(Z3);Z3==Player).
open([,,Z1,,Z2,,Z3,,],Player) :- (var(Z1);Z1==Player),(var(Z2);Z2==Player),(var(Z3);Z3==Player).

% evaluate board: o maximizes, x minimizes
value(B,100) :- win(B,o), !.
value(B,-100) :- win(B,x), !.
value(B,E) :-
    findall(1, open(B,o), L1), length(L1,Emax),
    findall(1, open(B,x), L2), length(L2,Emin),
    E is Emax - Emin.

% switch player
other(o,x). other(x,o).

% alpha-beta (negamax style)
alpha_beta(Player,0,B,_A,_B,_M,Value) :-
    value(B,Value).
alpha_beta(Player,D,B,A,B,Move,Value) :- % when A==B avoid infinite loop
    value(B,Value), Move = none.
alpha_beta(Player,D,B,Alpha,Beta,Move,Value) :-
    D > 0,
    findall((X,Y), mark(Player,B,X,Y), Moves),
    ( Moves = [] -> value(B,Value), Move = none
    ; D1 is D-1,
      evaluate_and_choose(Player,Moves,B,D1, -Beta, -Alpha, none, (Move,Value))
    ).

evaluate_and_choose(Player,[M|Ms],B,D,Alpha,Beta,Record,Best) :-
    move(Player,M,B,B1),
    other(Player,OP),
    alpha_beta(OP,D,B1,Alpha,Beta,_OM,V),
    V1 is -V,
    cutoff(Player,M,V1,D,Alpha,Beta,Ms,B,Record,Best).
evaluate_and_choose(,[],,,Alpha,,Move,(Move,Alpha)).

cutoff(,Move,Value,,,Beta,,,,(Move,Value)) :- Value >= Beta, !.
cutoff(Player,Move,Value,D,Alpha,Beta,Ms,B,_,Best) :-
    Alpha < Value, Value < Beta, !,
    evaluate_and_choose(Player,Ms,B,D,Value,Beta,Move,Best).
cutoff(Player,_,Value,D,Alpha,Beta,Ms,B,Record,Best) :-
    Value =< Alpha, !,
    evaluate_and_choose(Player,Ms,B,D,Alpha,Beta,Record,Best).

% debug spy no-op unless asserted
spy(,,_) :- true.

% interface
h(X,Y) :- record(x,X,Y), showBoard.
c :-
    board(B),
    ( alpha_beta(o,2,B,-1000,1000,Move,_V), Move \= none ->
        Move = (X,Y),
        record(o,X,Y),
        showBoard
    ; writeln('No move / game over'), showBoard ).

% display
showBoard :-
    board([Z1,Z2,Z3,Z4,Z5,Z6,Z7,Z8,Z9]),
    map_row([Z1,Z2,Z3]), map_row([Z4,Z5,Z6]), map_row([Z7,Z8,Z9]).

map_row([A,B,C]) :-
    write('    '), out(A), write(' '), out(B), write(' '), out(C), nl.

out(X) :- var(X), write('#').
out(X) :- nonvar(X), write(X).

run - init. h(2,2). c.
